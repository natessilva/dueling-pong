<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dueling Pong</title>
    <style>
      body {
        display: block;
        width: 90%;
        margin: 1em auto;
        max-width: 512px;
      }
      canvas {
        width: 100%;
        border: 1px solid black;
        box-sizing: border-box;
        image-rendering: crisp-edges;
      }
      span {
        margin-right: 1em;
      }
      #left {
        color: dimgray;
      }
      #right {
        color: blue;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <span id="left"></span>
    <span id="right"></span>
    <script>
      const boxSize = 512;
      const canvas = document.getElementById("canvas");
      canvas.width = boxSize;
      canvas.height = boxSize;
      const context = canvas.getContext("2d");
      const left = document.getElementById("left");
      const right = document.getElementById("right");

      const ball1 = { x: 0, y: 0 };
      const velocity1 = { x: 10, y: 8 };
      const ball2 = { x: 400, y: 300 };
      const velocity2 = { x: 8, y: 10 };
      const ballSize = 16;
      const boardSize = boxSize / ballSize;

      const board = Array.from({ length: boxSize / ballSize }).map((_, y) =>
        Array.from({ length: boxSize / ballSize }).map((_, x) => ({
          isLeft: x < ballSize,
        }))
      );

      // render initial board
      board.forEach((row, y) =>
        row.forEach(({ isLeft }, x) => {
          context.fillStyle = isLeft ? "dimgray" : "blue";
          context.fillRect(x * ballSize, y * ballSize, ballSize, ballSize);
        })
      );

      function getCollisions(position) {
        const x = Math.floor(position.x / ballSize);
        const y = Math.floor(position.y / ballSize);
        const collisions = [
          { x, y },
          { x, y: y + 1 },
          { x: x + 1, y },
          { x: x + 1, y: y + 1 },
        ].filter(
          (collision) =>
            collision.x >= 0 &&
            collision.x < boardSize &&
            collision.y >= 0 &&
            collision.y < boardSize
        );
        return collisions;
      }

      function updateBall(ball, velocity, isLeft) {
        // clear the old ball
        context.fillStyle = !isLeft ? "dimgray" : "blue";
        context.fillRect(
          Math.floor(ball.x),
          Math.floor(ball.y),
          ballSize,
          ballSize
        );
        const collisionsBefore = getCollisions(ball);
        ball.x += velocity.x;
        ball.y += velocity.y;
        // draw the new ball
        context.fillStyle = isLeft ? "dimgray" : "blue";
        context.fillRect(
          Math.floor(ball.x),
          Math.floor(ball.y),
          ballSize,
          ballSize
        );
        const collisionsAfter = getCollisions(ball);
        // only new collisions apply
        const collisions = collisionsAfter
          .filter(
            (collision) =>
              collisionsBefore.find(
                (c) => collision.x == c.x && collision.y == c.y
              ) == null
          )
          .filter((collision) => {
            return board[collision.y][collision.x].isLeft == isLeft;
          });

        const newVelocity = { x: velocity.x, y: velocity.y };

        // check for color colisions
        collisions.forEach((collision) => {
          // bounce in the direction of the larger distance
          if (
            Math.abs(collision.x * ballSize - ball.x) <
            Math.abs(collision.y * ballSize - ball.y)
          ) {
            const percent = Math.random() * 0.1 + 0.95;
            newVelocity.y = velocity.y * -1 * percent;
          } else {
            const percent = Math.random() * 0.1 + 0.95;
            newVelocity.x = velocity.x * -1 * percent;
          }
          const square = board[collision.y][collision.x];

          // flip the collision square
          square.isLeft = !square.isLeft;
          context.fillStyle = square.isLeft ? "dimgray" : "blue";
          context.fillRect(
            collision.x * ballSize,
            collision.y * ballSize,
            ballSize,
            ballSize
          );
        });

        velocity.x = newVelocity.x;
        velocity.y = newVelocity.y;
        // detect walls
        if (ball.x > boxSize - ballSize || ball.x < 0) {
          velocity.x *= -1;
        }
        if (ball.y > boxSize - ballSize || ball.y < 0) {
          velocity.y *= -1;
        }
      }

      function render() {
        updateBall(ball1, velocity1, false);
        updateBall(ball2, velocity2, true);
        const leftCount = board.flat().filter((square) => square.isLeft).length;
        const rightCount = boardSize * boardSize - leftCount;
        left.innerHTML = leftCount.toString();
        right.innerHTML = rightCount.toString();
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
